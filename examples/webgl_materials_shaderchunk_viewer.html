<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - shaderchunk viewer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>

			@font-face {
				font-family: 'inconsolata';
				src: url('files/inconsolata.woff') format('woff');
				font-weight: normal;
				font-style: normal;
			}

			body {
				background:#000;
				overflow: hidden;
				color:#fff;
				padding:0;
				margin:0;
				font-size: 10px;	
			}

			a {
				color: #ffffff;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				pointer-events: none;
				color: #ffffff;
				padding: 5px;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				z-index:1000;
			}

			.navigation{
				background-color: #121212;
				width: 100%;
				height: calc( 60px - 10px );
				padding: 5px 0px;				
			}

			.content{
				overflow: hidden;
				position: absolute;
				top: 60px; left: 0px;
				width: 100%;
				height: calc( 100% - 60px );				
			}

			.code-container{
				overflow: scroll;
				position: absolute;
				margin: 0px; padding: 0px;
				width: 100%;
				height: 100%;				
			}

			.code-line{
				display: inline;
			}

			#left-container{
				position: absolute;
				width: 50%;
				left: 0px; top: 0px;				
			}

			#right-container{	
				position: absolute;
				width: 50%;
				left: 50%; top: 0px;
			}


		</style>
		<link rel="stylesheet" type="text/css" href="js/libs/prism/prism.css">
	</head>

	<body>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> wegbl - shaderchunk viewer.
		</div>

		
		<script src="js/libs/prism/prism.js"></script>
		<script src="../build/three.js"></script>

		<div class="navigation">
			<select id="material-select">				
			</select>
			<form id="shader-select">
				<input type="radio" checked name="shader" value="vertexShader">vertex</input>
				<input type="radio" name="shader" value="fragmentShader">fragment</input>
			</form>

		</div>

		<div class="content">

			<div class="code-container language-glsl">

				<div id="left-container">
				</div>

				<div id="right-container">					
				</div>

			</div>

		</div>

		<script>

			var materialClasses = [
				[ 'MeshDepthMaterial', 'depth' ],
				[ 'MeshDistanceMaterial', 'distanceRGBA' ],
				[ 'MeshNormalMaterial', 'normal' ],
				[ 'MeshBasicMaterial', 'basic' ],
				[ 'MeshLambertMaterial', 'lambert' ],
				[ 'MeshPhongMaterial', 'phong' ],
				[ 'MeshToonMaterial', 'phong' ],
				[ 'MeshStandardMaterial', 'physical' ],
				[ 'MeshPhysicalMaterial', 'physical' ],
				[ 'LineBasicMaterial', 'basic' ],
				[ 'LineDashedMaterial', 'dashed' ],
				[ 'PointsMaterial', 'points' ],
				[ 'ShadowMaterial', 'shadow' ]
			];

			var materials = [];

			var renderer = new THREE.WebGLRenderer();
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(70,16/9,0.1,1000);
			var geometry = new THREE.PlaneBufferGeometry(1,1,1,1);

			var compileMaterial = function( MaterialClass ){

				var material = new MaterialClass();				
				var mesh = new THREE.Mesh( geometry,material );
				var shader;

				material.onBeforeCompile = function( shd ){
					shader = shd;
				}

				scene.add( mesh );
				renderer.render( scene, camera );
				scene.remove( mesh );
				
				return {
					type: material.type,
					vertexShaderPre: shader.vertexShader,
					vertexShaderPost: renderer.context.getShaderSource( material.program.vertexShader ),
					vertexShaderPreDom: null,
					vertexShaderPostDom: null,
					fragmentShaderPre: shader.fragmentShader,
					fragmentShaderPost: renderer.context.getShaderSource( material.program.fragmentShader ),
					fragmentShaderPreDom: null,
					fragmentShaderPostDom: null,
					domCreatedStatus: false
				}

			}

			var setLoadingStatus = function( value ){

			}			

			var encodeEntities = function( str ){
				return str.replace(/[\u00A0-\u9999<>\&]/gim, function(i) {
   					return '&#'+i.charCodeAt(0)+';';
				});
			}

			var createDomFragment = function( source, callback ){

				source = encodeEntities( source );
				var lines = source.split( '\n' ).map( function( line ){
					return `
					<div class="code-line">${ line }</div>
					`;
				});
				
				var root = document.createElement( 'div' );
				root.classList.add( 'language-glsl' );
				root.innerHTML = `
				<pre>
					<code id="code-block language-glsl">
						${ '\n' + source }
					</code>
				</pre>
				`;
				// domFragment.appendChild( root );
				Prism.highlightAllUnder( root, true, callback );

				return root;

			}

			var createDomFragments = function( materialInfo, callback ){

				if( materialInfo.domCreatedStatus ){
					callback( materialInfo );
					return;
				}
				var qCount = 0;
				var qCallBack = function(){
					qCount++;
					if( qCount === 4 ){
						setLoadingStatus( false );
						callback( materialInfo );
					}
				}

				setLoadingStatus( true );

				materialInfo.vertexShaderPreDom = createDomFragment( materialInfo.vertexShaderPre, qCallBack );
				materialInfo.vertexShaderPostDom = createDomFragment( materialInfo.vertexShaderPost, qCallBack );
				materialInfo.fragmentShaderPreDom = createDomFragment( materialInfo.fragmentShaderPre, qCallBack );
				materialInfo.fragmentShaderPostDom = createDomFragment( materialInfo.fragmentShaderPost, qCallBack );

				materialInfo.domCreatedStatus = true;

			}

			// Compile Material Source.

			var materialInfo;
			for( var i = 0; i<materialClasses.length; i++ ){
				materialInfo = compileMaterial( THREE[ materialClasses[i][0] ] );
				materials.push( materialInfo );
			}
			
			// Build Material Select

			var materialSelect = document.getElementById( 'material-select' );
			var option;

			for( var i = 0; i<materials.length; i++ ){

				option = document.createElement( 'option' );
				option.text = materials[i].type;
				materialSelect.options.add( option );

			}

			// Handle Shader Type Input

			var shaderSelect = document.getElementById( 'shader-select' );


			var onChangeMaterial = function( index ){

				materialSelect.selectedIndex = index;				

				var leftContainer = document.getElementById( 'left-container' );
				var rightContainer = document.getElementById( 'right-container' );

				if( leftContainer.children.length ){
					leftContainer.removeChild( leftContainer.children[0] );
				}
				
				if( rightContainer.children.length ){
					rightContainer.removeChild( rightContainer.children[0] );
				}				

				createDomFragments( materials[index], function( materialInfo ){

					var shaderType = shaderSelect.elements[ 'shader' ].value;

					switch( shaderType ){
						case 'vertexShader':
							leftContainer.appendChild( materialInfo.vertexShaderPreDom );
							rightContainer.appendChild( materialInfo.vertexShaderPostDom );						
							break;

						case 'fragmentShader':
							leftContainer.appendChild( materialInfo.fragmentShaderPreDom );
							rightContainer.appendChild( materialInfo.fragmentShaderPostDom );
							break;

					}

				});

			}

			materialSelect.onchange = function(ev){

				onChangeMaterial( materialSelect.selectedIndex );

			}

			shaderSelect.onchange = function(){

				onChangeMaterial( materialSelect.selectedIndex );

			}
			
			onChangeMaterial( 5 ); // Phong

		</script>

	</body>
</html>
